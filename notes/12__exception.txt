Exception Handling


- event that happens during the execution of the program
- disrupts the normal flow and creates an Exception object.
- Exception object contains 3 things ( Exception type, message and stack trace)
- when an exception occurs, runtime system tries to handle the exception based on this exception object from the point of error event, to each step back till where the exception can be handled. If no class/method can handle the event, program is terminated with exception object
---------------------------------------------------------------------------------------------------


Exception Hierarchy


- `Object` is the parent class of every class
- it has 1 of the child class named `Throwable`
- `Throwable` has 2 child classes, "Error" and "Exception"
- Error has 2 classes StackOverflowError and OutofMemoryError
- for Error, we cannot and should not do anything, and they are related to JVM.


- for Exception, it has occurred from our code and must be handled
---------------------------------------------------------------------------------------------------


2 Types of Exception

- Unchecked / Runtime Exception: code will get compiled and program will fail
- Checked / Compile time Exception: code will not get compiled if not handled
---------------------------------------------------------------------------------------------------


IMPORTANT DIFFERENCE:
- in runtime exceptions, the compiler will NOT force to handle the exception using throws or try-catch blocks.
- in compile time exceptions, the compiler will FORCE to handle the exception during compilation using throws / try-catch.
eg:

// runtime : below code will compile

public static void method1 {
    throw new ArithmeticException();
}

// compile time : below code will give error during compilation.
public static void method1 {
    throw new ClassNotFoundException();
}
// to compile the above code, either handle the exception using `throws` on method1, which means method1 delegates the caller to handle the exception [this can go on till any levels upto the parent caller]. OR handle the exception within method1 using try-catch [or any parent caller].

NOTE: without having catch here, and rather using finally, the problem will still remain, and compilation error. so MUST catch in "catch" block only OR pass to caller using throws

eg:
public static void main .... {
    try {
        method1();
    } catch (ClassNotFoundException exceptionObject) {
        exceptionObject.printStackTrace();
    }
}
public static void method1() throws ClassNotFoundException {
    throw new ClassNotFoundException();
}


- `throws` keyword is applied to a method which means the code inside method might generate an exception of the type given after throws keyword and if it does, then, pass the exception to the caller
---------------------------------------------------------------------------------------------------


Unchecked / Runtime Exception


1. ClassCastException:
Object val = 0;  // val is java.lang.Integer;
System.out.println((String) val));  // exc. // cannot convert to java.lang.String

2. ArithmeticException:
- divide by 0, etc.

3. IndexOutOfBoundsException:
- ArrayIndexOutOfBoundsException, StringIndexOutOfBoundsException

4. NullPointerException:
- if an object is null, and trying to access it using . or some other way
eg: String val = null; System.out.println(val.chatAt(2));

5. IllegalArgumentException:
- child class NumberFormatException
- eg: int val = Integer.parseInt("abc");
---------------------------------------------------------------------------------------------------
Checked / Compile time exception

1. ClassNotFoundException
---------------------------------------------------------------------------------------------------


Handling Exceptions


1. try-catch block:

- try block contains the code that can generate the exception ( this included calling another method, say method1 )
- catch block is used to handle ALL types of exception that can be thrown by the try block.

- IMPORTANT NOTE: catch block cannot be used to handle any other exception that is not generated by the try block
- 3 scenarios: try-catch , try-catch-finally , try-finally


eg:

public static void main(String[] args) {
    try {
        method1("dummy");
    }
    catch (ClassNotFoundException exceptionObject) {
        //
    }
    catch (InterruptedException exceptionObject) {
        //
    }
    /* comment because this catch block will give error
    catch (FileNotFoundException exceptionObject) {
        //
    }
    */
}
public static void method1(String name) throws ClassNotFoundException, InterruptedException {
    if(name.equals("dummy")) {
        throw new ClassNotFoundException();
    } else {
        throw new InterruptedException();
    }
}
---------------------------------------------------------------------------------------------------

2. Using parent Exception in catch

catch(Exception exceptionObject) {
    //
}

- this is the parent of all kinds of exceptions.
- hence, MUST be the last catch otherwise, it will catch any exception and any catch below will not be able to catch it
---------------------------------------------------------------------------------------------------

3. catch multiple exceptions in a single catch block

catch (ClassNotFoundException | InterruptedException exceptionObject) {
    //
}
---------------------------------------------------------------------------------------------------

4. try-finally OR try-catch-finally

- always gets executed
- at most 1 finally can be present
- Used for : logging / file or object closing or cleanups
- NOTE: does NOT get executed when JVM issues occur ( the above 2 errors )

finally {
    //
}

IMPORTANT NOTE: if try block generates a compile time exception for which the catch is not present but finally is present, then finally CANNOT handle it. in such case, this calling method should have `throws` of the same exception to handle to its parent caller. if no caller is present, program will terminate. for runtime exceptions, compiler will not force to catch
---------------------------------------------------------------------------------------------------

`throw` keyword

- to throw the exception and have the method throws
- to re-throw the exception from the catch of the caller method and marking the method throws, and let its caller method to handle it
---------------------------------------------------------------------------------------------------


Custom defined Exceptions

- work like checked / compile time exceptions
- handle them at compile time using throws, try-catch
- subclasses of Exception / any specific Exception class

public class MyCustomException extends Exception {
    MyCustomException(String message) {
        super(message);
    }
}
public static void method throws MyCustomException {
    throw new MyCustomException("problem");
}